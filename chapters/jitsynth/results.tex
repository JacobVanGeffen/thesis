\section{Evaluation}\label{s:eval}

This section evaluates \jitsynth by answering the following research questions:
\begin{enumerate}[label={},leftmargin=0em]
  \item \textbf{RQ1}: Can \jitsynth synthesize correct and performant compilers for
  real-world source and target languages?
  % \item \textbf{RQ2}: Can \jitsynth synthesize a wide variety of compilers?
  \item \textbf{RQ2}: How effective are the sketch optimizations described in \autoref{s:algorithm}?
\end{enumerate}


\subsection{Synthesizing compilers for real-world source-target pairs}

% \begin{figure}
%   \centering
%   \input{figs/lang-desc.tex}
%   \vspace{1.5em}\newline
%   \input{figs/lsc-lang.tex}
%   \caption{Description of eBPF, RISC-V, classic BPF, and libseccomp languages}
%   \label{fig:lang}
% \end{figure}

\begin{figure}[h]
  \resizebox{\textwidth}{!}{
  \input{figs/cycles.pgf}
  }
  \caption{Execution time of eBPF benchmarks on the HiFive Unleashed
  RISC-V development board, using the existing Linux eBPF to RISC-V
  compiler, the \jitsynth compiler, and the Linux eBPF interpreter.
  Measured in processor cycles.}
  \label{fig:b2r-runtime}
\end{figure}

To demonstrate the effectiveness of \jitsynth,
we applied \jitsynth to synthesize compilers for three different
source-target pairs: eBPF to 64-bit RISC-V, classic BPF to eBPF,
and libseccomp to eBPF.
%
This subsection describes our results for each of the synthesized
compilers.
%


\paragraph{eBPF to RISC-V.}

As a case study, we applied \jitsynth to synthesize
a compiler from eBPF to 64-bit RISC-V.
%
It supports 87 of the 102 eBPF instruction opcodes;
unsupported eBPF instructions include function calls,
endianness operations, and atomic instructions.
%
To validate that the synthesized compiler is correct, we ran the existing
eBPF test cases from the Linux kernel; our compiler passes all test cases
it supports. % 228 supported / 234 total ebpf
%
In addition, our compiler avoids bugs previously found in the existing
Linux eBPF-to-RISC-V compiler in Linux~\cite{nelson:bpf-riscv-add32-bug}.
%
To evaluate performance, we compared against the existing Linux compiler.
%
We used the same set of benchmarks used by Jitk~\cite{wang:jitk},
which includes system call filters from widely used applications.
%
Because these benchmarks were originally for classic BPF,
we first compile them to eBPF using the existing
Linux classic-BPF-to-eBPF compiler as a preprocessing step.
%
To run the benchmarks, we execute the generated
code on the HiFive Unleashed RISC-V development board~\cite{sifive:fu540-c000}, measuring
the number of cycles.
%
As input to the filter, we use a system call number that is allowed
by the filter to represent the common case execution.


\autoref{fig:b2r-runtime} shows the results of the performance evaluation.
%
eBPF programs compiled by \jitsynth JIT compilers show an average slowdown of $\EbpfCompilerSlowdown\times$
compared to programs compiled by the existing Linux compiler.
%
This overhead results from additional complexity in the compiled eBPF jump instructions.
%
Linux compilers avoid this complexity by leveraging
bounds on the size of eBPF jump offsets.
%
\jitsynth-compiled programs get an average speedup of $\EbpfInterpSpeedup\times$
compared to interpreting the eBPF programs.
%
This evidence shows that \jitsynth can synthesize a compiler that outperforms
the current Linux eBPF interpreter, and nears the performance of the Linux
compiler, while avoiding bugs.
%

\paragraph{Classic BPF to eBPF.}

\begin{figure}[h]
  \resizebox{\textwidth}{!}{
  \input{figs/o2b-cc.pgf}
  \input{figs/l2b-cc.pgf}
  }
  \caption{Performance of code generated by \jitsynth compilers
  compared to existing compilers for the classic BPF to eBPF benchmarks
  (left) and the libseccomp to eBPF benchmarks (right). Measured in number
  of instructions executed.}
  \label{fig:o2b-l2b-runtime}
\end{figure}

Classic BPF is the original, simpler version of BPF used for packet filtering which
was later extended to eBPF in Linux.
%
Since many applications still use classic BPF, Linux must first compile classic BPF
to eBPF as an intermediary step before compiling to machine instructions.
%
As a second case study, we used \jitsynth to synthesize a compiler from classic BPF to eBPF.
%
Our synthesized compiler supports all classic BPF opcodes.
%
To evaluate performance, we compare against the existing
Linux classic-BPF-to-eBPF compiler.
%
Similar to the RISC-V benchmarks, we run each eBPF program
with input that is allowed by the filter.
%
Because eBPF does not run directly on hardware, we measure
the number of instructions executed instead of processor cycles.


\autoref{fig:o2b-l2b-runtime} shows the performance results.
%
Classic BPF programs generated by \jitsynth compilers execute
an average of $\CbpfSlowdown\times$ more instructions
than those compiled by Linux.


\paragraph{libseccomp to eBPF.}

libseccomp is a library used to simplify construction of BPF system call filters.
%
The existing libseccomp implementation compiles to classic BPF; we instead choose
to compile to eBPF because classic BPF has only two registers, which does not satisfy
the assumptions of \jitsynth.
%
Since libseccomp is a library and does not have distinct instructions, libseccomp itself does not meet the definition of an abstract register machine; we instead introduce
an intermediate libseccomp language which does satisfy this definition.
%
Our full libseccomp to eBPF compiler is composed of both a trusted program to translate from libseccomp to our intermediate language and a synthesized compiler from our intermediate language to eBPF.

To evaluate performance, we select a set of benchmark filters from real-world
applications that use libseccomp, and measure the number of eBPF instructions
executed for an input the filter allows.
%
Because no existing compiler exists from libseccomp to eBPF directly,
we compare against the composition of the existing libseccomp-to-classic-BPF and classic-BPF-to-eBPF compilers.


\autoref{fig:o2b-l2b-runtime} shows the performance results.
%
libseccomp programs generated by \jitsynth execute
$\LibseccompSlowdown\times$ more instructions on average
compared to the existing libseccomp-to-eBPF compiler stack.
%
However, the synthesized compiler avoids bugs previously found
in the libseccomp-to-classic-BPF compiler~\cite{lsc:bug}.
%
% This shows that \jitsynth can synthesize a compiler for a new
% source-target pair that approaches the performance of the existing
% compiler stack. % This sentence is super weird
%
% At the same time, the synthesized compiler avoids bugs previously
% found in the libseccomp-to-classic-BPF compiler~\cite{lsc:bug}.
%



% \if 0
% \autoref{fig:lang} describes the instructions in both instruction sets.
% %
% Our compiler supports a subset of
% %

% To validate that the synthesized compiler is correct, we ran the existing eBPF
% test suite in the Linux kernel.
% %
% In addition to passing these tests, our compiler also avoids bugs previously
% found in the existing eBPF to RISC-V compiler in Linux~\cite{nelson:bpf-riscv-add32-bug}.
% %
% This evidence shows that \jitsynth can synthesize reliable compilers for real-world DSLs.


% We evaluated the performance of code generated by the synthesized compiler against
% both the existing Linux eBPF to RISC-V compiler and the Linux eBPF interpreter.
% %
% Our evaluation uses the same set of benchmarks used by Jitk~\cite{wang:jitk}, which includes system call filters from widely used applications.
% %OpenSSH, vsftpd, Native Client (NaCl), QEMU, Firefox, Chrome, and Tor.
% %
% Because these benchmarks were originally for classic BPF,
% we first compile them to eBPF using the existing
% Linux classic BPF to eBPF compiler as a preprocessing step.
% %
% We ran all benchmarks on the HiFive Unleashed RISC-V development board, and measured
% the total number of processor cycles executed in the common case, for each filter
% and for each execution method.



% \autoref{fig:b2r-runtime} shows the results of the performance evaluation.
% %
% eBPF programs compiled by \jitsynth JIT compilers show an average slowdown of $\EbpfCompilerSlowdown\times$
% compared to programs compiled by the existing Linux compiler.
% %
% This overhead is from \todo{XXX}.
% %
% \jitsynth-compiled programs get an average speedup of $\EbpfInterpSpeedup\times$
% compared to interpreting the eBPF programs, preserving the benefit
% of JIT compilation.
% %
% %In addition, \jitsynth compilers avoid \todo{previously found bugs in the Linux compiler}.
% %
% This is evidence that \jitsynth can synthesize a compiler that outperforms
% %
% This shows that \jitsynth can synthesize a compiler for a real-world source-target pair,
% which out-performs the existing interpreter and nears the performance of the existing compiler.
% %
% ISA-level optimizations could reduce this performance gap between the \jitsynth compiler
% and the Linux compiler, but we consider this to be outside the scope of our work.
% %
% \fi

% We also evaluated the performance of code generated by the \jitsynth eBPF-to-RISC-V compiler, comparing it to both the existing Linux compiler as well as the Linux eBPF interpreter.
% To give a more realistic comparison, we also applied a simple NOP-removal pass on top of the \jitsynth compiler.
% This pass, done by trusted code, removes NOP instructions from code generated by the \jitsynth compiler
% while preserving the semantics of the code.
% \todo{it's odd to bring up NOP removal for the first time here.
% maybe add this part to the actual JIT (rather than a patch)?}
%To further improve the speed of code generated by the \jitsynth compiler, further optimization passes could also be made.

\if 0
\subsection{Synthesizing compilers for multiple source-target pairs}


%NB: should this subsection and the previous section be merged? they
%    seem to be making similar claims

%NB: this section is very repetitive. We probably can factor
%    the libseccomp->ebpf and cbpf->ebpf portions to minimize
%    the space it takes up

To demonstrate the generality of our approach, we also apply \jitsynth to
synthesize compilers for two additional source and target pairs:
classic BPF to eBPF, and libseccomp to eBPF.
%
Classic BPF is the original, simpler version of BPF used for packet filtering which
was later extended to eBPF in Linux.
%
Since many applications still use classic BPF, Linux must first compile classic BPF
to eBPF as an intermediary before compiling to machine instructions.
%
libseccomp is a library used to simplify construction of BPF system call filters.
%
The existing libseccomp implementation compiles to classic BPF; we instead choose
to compile to eBPF as classic BPF has only two registers, which does not satisfy
the assumptions of \jitsynth.
%
Since libseccomp is a library and does not have distinct instructions, libseccomp itself does not meet the definition of an abstract register machine; we instead introduce
an intermediate libseccomp language which does satisfy this definition.
%
Our full libseccomp to eBPF compiler is composed of both a trusted program to translate from libseccomp to our intermediate language and a synthesized compiler from our intermediate language to eBPF.


To evaluate the compilers generated by \jitsynth, we compile a set of benchmarks
to eBPF and perform a worst-case execution analysis on the generated code, and
compare against the existing implementation.
%
Because no existing compiler exists from libseccomp to eBPF directly,
we compare against the composition of the libseccomp to classic BPF implementation and the
existing Linux classic BPF to eBPF compiler.
%
The classic BPF benchmarks are the same used in Jitk; the libseccomp benchmarks
are selected from a handful of real-world applications.
%
\autoref{fig:o2b-l2b-runtime} shows the results of the analysis.
%
Classic BPF program generated by \jitsynth compilers execute
an average of $\CbpfSlowdown\times$ more instructions in the worst case
than those compiled Linux.
%
Similarly, libseccomp programs generated by \jitsynth show a
$\LibseccompSlowdown\times$ slowdown compared to the existing libseccomp
to eBPF compiler stack.
%
These results show that \jitsynth can generate compilers which generate
code that approaches the performance of existing compilers, while avoiding
bugs like those previously found in the libseccomp compiler~\cite{lsc:bug}.
%


\if 0
We evaluate our synthesized classic BPF to eBPF compiler using the same benchmarks
as in Jitk.
%
To compare our compiler against the existing Linux compiler, we compile each
benchmark to eBPF, and perform a worst-case execution analysis of the generated
code, measuring the number of eBPF instructions executed.
%
\autoref{fig:o2b-l2b-runtime} shows the results of this analysis.
%
BPF programs compiled by \jitsynth compilers execute an average of
$\CbpfSlowdown\times$ more instructions in the worst case than those
compiled by Linux.
%
This shows that the \jitsynth-synthesized compiler generates code
near the performance of that generated by Linux.
%
% The results for both source-target pairs are shown in \autoref{fig:o2b-l2b-runtime}.

% Classic BPF is the original version of BPF used for packet filtering, later expanded into eBPF.
% Since many applications still use classic BPF, compiling to eBPF is an essential step for running these filters.
% In particular, each of the applications discussed in the previous section emits classic BPF filters, which are compiled into eBPF in the kernel.
% In this section, we compare the compiler that \jitsynth synthesizes to the existing classic BPF to eBPF compiler in the Linux kernel using these same filters.
% For each filter, we evaluate the worst-case execution time of the compiled eBPF code in number of instructions.
% On average, filters compiled by the \jitsynth compiler suffer an average slowdown of \todo{$2.94\times$} compared to the Linux kernel compiler for classic BPF.

In addition to classic BPF, we also synthesize a compiler for libseccomp,
a library used to build classic BPF system call filters.
%
Though libseccomp itself compiles to classic BPF, we choose to generate a compiler from libseccomp to eBPF.
%
We do so because no compiler currently exists from libseccomp to eBPF, and because
classic BPF has only two registers, which does not meet our assumptions for \jitsynth.
%
Since libseccomp is a library and does not have distinct instructions, libseccomp itself does not match the assumptions of an abstract register machine.
%
However, we introduce an intermediate libseccomp language which does meet these assumptions.
%
Our full libseccomp to eBPF compiler is composed of both a trusted program to translate from libseccomp to our intermediate language and a synthesized compiler from our intermediate language to eBPF.
%
This compiler avoids bugs found in the current libseccomp implementation~\cite{lsc:bug}.

We evaluate our compiler using benchmarks taken from a handful of real-world applications
that use libseccomp, including Ctags, Lepton, LibreOffice, OpenSSH, and vsftpd.
%
To compare against the existing libseccomp compiler, we compile the libseccomp
filters to classic BPF using the existing compiler, and then into eBPF using
the Linux classic BPF to eBPF compiler.
%
We compare this result the code generated by our synthesized libseccomp to eBPF compiler,
using the same worst-case execution analysis.
%
The \jitsynth compiler has a $\LibseccompSlowdown\times$ compared to the
existing libseccomp to eBPF compiler stack.
%
% NB: What's the point to make here?
%
\fi
\fi

\subsection{Effectiveness of sketch optimizations}

\begin{figure}[h]
  % \resizebox{\textwidth}{!}{
  % \input{figs/b2r-synth-time.pgf}
  % \input{figs/o2b-synth-time.pgf}
  % }
  % \begin{center}
  %   \resizebox{.5\textwidth}{!}{
  %   \input{figs/l2b-synth-time.pgf}
  %   }
  % \end{center}
  % \caption{Synthesis time per instruction for our three source-target pairs.
  % % TODO do things other than color-code (i.e. different types of ticks)
  % Green corresponds to \Naive sketches.
  % Orange corresponds to \RW sketches.
  % Blue corresponds to \LCS sketches.
  % A red X indicates that synthesis timed out or ran out of memory after that point.}

\begin{center}
\begin{tabular}{l|c|c|c}

\toprule
  Compiler & \Naive sketch & \RW sketch & \LCS sketch \\
\midrule
  eBPF to RISC-V & X & X & 44.4h \\
  classic BPF to eBPF & X & X & 1.2h \\
  libseccomp to eBPF & 4.0h & 43.5m & 7.1m  \\
\bottomrule
\end{tabular}
\end{center}

\caption{
Synthesis time for each source-target pair, broken
down by set of optimizations used in the sketch.
An X indicates that synthesis either timed out
or ran out of memory.}


  \label{fig:o2b-l2b-synthtime}
\end{figure}

In order to evaluate the effectiveness of the search optimizations
described in \autoref{s:algorithm}, we measured the time \jitsynth
takes to synthesize each of the three compilers with different optimizations
enabled.
%
Specifically, we run \jitsynth in three different configurations:
(1) using \Naive sketches, (2) using \RW sketches, and (3) using \LCS sketches.
%
For each configuration, we ran \jitsynth with a timeout of 48 hours (or until out of memory).
\autoref{fig:o2b-l2b-synthtime} shows the time to synthesize
each compiler under each configuration.
%
Note that these figures do not include time spent computing read and write sets,
which takes less than 11 minutes for all cases.
%
% The order instructions are synthesized in is fixed across configurations.
% %
Our results were collected using an 8-core AMD Ryzen 7 1700 CPU with 16~GB memory,
running Racket v7.4 and the Boolector~\cite{niemetz:boolector} solver v3.0.1-pre.


When synthesizing the eBPF-to-RISC-V compiler,
\jitsynth runs out of memory with \Naive sketches,
reaches the timeout with \RW sketches,
and completes synthesis with \LCS sketches.
%
For the classic-BPF-to-eBPF compiler,
\jitsynth times out with both \Naive sketches and \RW sketches.
\jitsynth only finishes synthesis with \LCS sketches.
%
For the libseccomp-to-eBPF compiler, all configurations finish,
but \jitsynth finishes synthesis about $\LibseccompSynthSpeedup\times$ times faster
with \LCS sketches than with \Naive sketches.
%
These results demonstrate that the techniques \jitsynth uses
are essential to the scalability of JIT synthesis.
