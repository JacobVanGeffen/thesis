\begin{figure}
\begin{minipage}[t]{0.49\linewidth}
  \begin{lstlisting}[
   language=Rust, basicstyle=\tiny\ttfamily, numbers=left,
   xleftmargin=11pt,
   numbersep=5pt,
]
type EGraph = egg::EGraph<Lambda, LambdaAnalysis>;
struct LambdaAnalysis;
struct FC {
  free: HashSet<Id>,    // our analysis data stores free vars
  constant: Option<Lambda>, // and the constant value, if any
}

// helper function to make pattern meta-variables
fn var(s: &str) -> Var { s.parse().unwrap() }

impl Analysis<Lambda> for LambdaAnalysis {
  type Data = FC; // attach an FC to each eclass
  // merge implements semilattice join by joining into `to`
  // returning true if the `to` data was modified
  fn merge(&self, to: &mut FC, from: FC) -> bool {
    let before_len = to.free.len();
    // union the free variables
    to.free.extend(from.free.iter().copied());
    if to.constant.is_none() && from.constant.is_some() {
      to.constant = from.constant;
      true
    } else {
      before_len != to.free.len()
    }
  }

  fn make(egraph: &EGraph, enode: &Lambda) -> FC {
    let f = |i: &Id| egraph[*i].data.free.iter().copied();
    let mut free = HashSet::default();
    match enode {
      Use(v) => { free.insert(*v); }
      Let([v, a, b]) => {
        free.extend(f(b)); free.remove(v); free.extend(f(a));
      }
      Lambda([v, b]) | Fix([v, b]) => {
        free.extend(f(b)); free.remove(v);
      }
      _ => enode.for_each_child(
             |c| free.extend(&egraph[c].data.free)),
    }
    FC { free: free, constant: eval(egraph, enode) }
  }

  fn modify(egraph: &mut EGraph, id: Id) {
    if let Some(c) = egraph[id].data.constant.clone() {
      let const_id = egraph.add(c);
      egraph.union(id, const_id);
    }
  }
}\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}[t]{0.46\linewidth}
  \begin{lstlisting}[language=Rust, basicstyle=\tiny\ttfamily, escapechar=@, numbers=left, firstnumber=51,
   numbersep=7pt,
]
// evaluate an enode if the children have constants
// Rust's `?` extracts an Option, early returning if None
fn eval(eg: &EGraph, enode: &Lambda) -> Option<Lambda> {
  let c = |i: &Id| eg[*i].data.constant.clone();
  match enode {
    Num(_) | Bool(_) => Some(enode.clone()),
    Add([x, y]) => Some(Num(c(x)? + c(y)?)),
    Eq([x, y]) => Some(Bool(c(x)? == c(y)?)),
    _ => None,
  }
}

// Functions of this type can be conditions for rewrites
trait ConditionFn = Fn(&mut EGraph, Id, &Subst) -> bool;

// The following two functions return closures of the
// correct signature to be used as conditions in @\autoref{fig:lambda-rules}@.
fn is_not_same_var(v1: Var, v2: Var) -> impl ConditionFn {
    |eg, _, subst| eg.find(subst[v1]) != eg.find(subst[v2])
}
fn is_const(v: Var) -> impl ConditionFn {
     // check the LambdaAnalysis data
    |eg, _, subst| eg[subst[v]].data.constant.is_some()
}

struct CaptureAvoid {
  fresh: Var, v2: Var, e: Var,
  if_not_free: Pattern<Lambda>, if_free: Pattern<Lambda>,
}

impl Applier<Lambda, LambdaAnalysis> for CaptureAvoid {
  // Given the egraph, the matching eclass id, and the
  // substitution generated by the match, apply the rewrite
  fn apply_one(&self, egraph: &mut EGraph,
               id: Id, subst: &Subst) -> Vec<Id>
  {
    let (v2, e) = (subst[self.v2], subst[self.e]);
    let v2_free_in_e = egraph[e].data.free.contains(&v2);
    if v2_free_in_e {
      let mut subst = subst.clone();
      // make a fresh symbol using the eclass id
      let sym = Lambda::Symbol(format!("_{}", id).into());
      subst.insert(self.fresh, egraph.add(sym));
      // apply the given pattern with the modified subst
      self.if_free.apply_one(egraph, id, &subst)
    } else {
      self.if_not_free.apply_one(egraph, id, &subst)
    }
  }
}\end{lstlisting}
  % \caption{
  %   Some of the rewrites in \autoref{fig:lambda-rules} are conditional,
  %     requiring conditions like \texttt{is\_not\_same\_var} or \texttt{is\_const}.
  %   Others are fully dynamic, using a custom applier like \texttt{CaptureAvoid}
  %     instead of a syntactic right-hand side.
  %   Both conditions and custom appliers can use the computed data from the
  %     \eclass analysis; for example, \texttt{CaptureAvoid} only $\alpha$-renames if
  %     there might be a name collision.
  % }
\end{minipage}
\caption[\Eclass analysis and conditional/dynamic rewrites for the lambda calculus]{
Our partial evaluator example highlights three important features \egg provides
  for extensibility: \eclass analyses, conditional rewrites, and dynamic
  rewrites.
  
The \texttt{LambdaAnalysis} type, which implements the \texttt{Analysis} trait,
  represents the \eclass analysis.
Its associated data (\texttt{FC}) stores
  the constant term from that \eclass (if any) and
  an over-approximation of the free variables used by terms in that \eclass.
The constant term is used to perform constant folding.
The \texttt{merge} operation implements the semilattice join, combining the free
  variable sets and taking a constant if one exists.
In \texttt{make}, the analysis computes the free variable sets based on the
  \enode and the free variables of its children;
  the \texttt{eval} generates the new constants if possible.
The \texttt{modify} hook of \texttt{Analysis} adds the constant to the \egraph.

Some of the conditional rewrites in \autoref{fig:lambda-rules} depend on
  conditions defined here.
Any function with the correct signature may serve as a condition.

The \texttt{CaptureAvoid} type implements the \texttt{Applier} trait, allowing
  it to serve as the right-hand side of a rewrite.
\texttt{CaptureAvoid} takes two patterns and some pattern variables.
It checks the free variable set to determine if a capture-avoiding substitution
  is required, applying the \texttt{if\_free} pattern if so and the
  \texttt{if\_not\_free} pattern otherwise.
}
\label{fig:lambda-applier}
\label{fig:lambda-analysis}
\end{figure}

%%% Local Variables:
%%% TeX-master: "../thesis"
%%% End:
